Table of Content

[Naive Approach] By using two nested loops – O(n ^ 2) Time and O(1) Space
[Expected Approach] By using HashSet Data Structure – O(n) Time and O(n) Space
[Other Approach] By Sorting the array - O(n*log n) Time and O(1) Space
--------------------------------------------
[Naive Approach] By using two nested loops – O(n ^ 2) Time and O(1) Space
The simple idea is to use a nested loop to compare each element in the array with every other element. If any two elements are found to be the same, return true, indicating the array has a duplicate element. If no duplicates are found after all comparisons, return false.

// Java Program check if there are any duplicates 
// in the array using nested loops approach 

import java.util.*;

class GfG {
    static boolean checkDuplicates(int[] arr) {
		int n = arr.length;
      	
        // Outer loop to pick each element one by one
        for (int i = 0; i < n - 1; i++) {
          
            // Inner loop to compare the current element 
          	// with the rest of the elements
            for (int j = i + 1; j < n; j++) {
              
                // If a duplicate is found Return true
                if (arr[i] == arr[j])
                    return true;
            }
        }

        // If no duplicates are found, return false
        return false;
    }

    public static void main(String[] args) {
        int[] arr = {4, 5, 6, 4};
        System.out.println(checkDuplicates(arr));
    }
}

Output
true
--------------------------------------------
Time Complexity: O(N2), As we are using nested loop over the given array, where N is the number of elements in the given array.
Auxiliary Space: O(1), As we are not using any extra space.

[Expected Approach] By using HashSet Data Structure – O(n) Time and O(n) Space
The main idea is to insert each value into a HashSet, which only stores unique elements. If any insertion fails or if any elements are already exits in HashSet, it means a duplicate exists, so return true. If all insertions succeed, it indicates that all elements are unique, so return false.

// Java Program check if there are any duplicates  
// in the array using Hashing

import java.util.HashSet;
import java.util.Set;

class GfG {
  
    // Function to check if there are any duplicates 
    static boolean checkDuplicates(int[] arr) {
        int n = arr.length;

        // Create a HashSet to store the unique elements
        Set<Integer> st = new HashSet<>();

        // Iterate through each element
        for (int i = 0; i < n; i++) {
          	
            // If the element is already present, return true
            // Else insert the element into the set
            if (st.contains(arr[i]))
                return true;
            else
                st.add(arr[i]);
        }

        // If no duplicates are found, return false
        return false;
    }

    public static void main(String[] args) {
        int[] arr = { 4, 5, 6, 4 };
        System.out.println(checkDuplicates(arr));
    }
}

Output
true

Time Complexity: O(n), As we are traversing over the array once.
Auxiliary space: O(n), As we are using unordered set which takes O(n) space in worst case, where n is the size of the array.
--------------------------------------------
[Other Approach] By Sorting the array - O(n * log(n)) Time and O(1) Space
The main idea is to first sort the array arr[] and then iterate through it to check if any adjacent elements are equal. If a pair of adjacent elements is equal, the function returns true, indicating the presence of duplicates. If no duplicates are found after traversing the entire array, the function returns false.

// Java Program check if there are any duplicates  
// in the array using Sorting

import java.util.Arrays;

class GFG {
    static boolean checkDuplicates(int[] arr) {
      	int n = arr.length;
      	
        // Sort the array
        Arrays.sort(arr);

        // Iterate through the sorted array
        for (int i = 1; i < n; i++) {
          
            // Check if adjacent elements are equal
            if (arr[i] == arr[i - 1])
                return true;
        }
      
      	// If no duplicates are found, return false
        return false;
    }

    public static void main(String[] args) {
        int[] arr = { 4, 5, 6, 4 };
        System.out.println(checkDuplicates(arr));
    }
}

Output
true
Time Complexity: O(n * logn), As we are using sorting function which takes nlogn time.
Auxiliary space: O(1), As we are not using extra space.
--------------------------------------------
